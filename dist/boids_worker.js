/*! For license information please see boids_worker.js.LICENSE.txt */
(()=>{"use strict";var __webpack_modules__={"./src/boids/BoidsController.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => /* binding */ BoidsController\n/* harmony export */ });\n/* harmony import */ var _Entity_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Entity.js */ "./src/boids/Entity.js");\n/* harmony import */ var _Grid_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Grid.js */ "./src/boids/Grid.js");\n;\n\n\n/**\n * @module BoidsController \n * BoidsController class defines a container for boids entities.\n * All entities (flock or obstalces) are added to BoidsController.\n * BoidsController calculates and updates entity positions and velocities.\n */\nclass BoidsController {\n    /**\n     * Constructor for the BoidsController\n     * @param {Number} boundaryX world size in x axis\n     * @param {Number} boundaryY world size in y axis\n     * @param {Number} boundaryZ world size in z axis\n     * @param {Number} subDivisionCount subdivision count defines the grid size. \n     * If it is given 10, world will be splitted into 10*10*10 cubes for spatial partitioning.\n     */\n    constructor(boundaryX = 500, boundaryY = 500, boundaryZ = 500, subDivisionCount = 1) {\n        const maxSize = Math.max(boundaryX, boundaryY, boundaryZ);\n        this.grid = new _Grid_js__WEBPACK_IMPORTED_MODULE_1__.default(maxSize, maxSize / subDivisionCount);\n        this.subDivisionCount = subDivisionCount;\n\n        this.flockEntities = [];\n        this.obstacleEntities = [];\n\n        this.boundaryX = boundaryX;\n        this.boundaryY = boundaryY;\n        this.boundaryZ = boundaryZ;\n\n        this.aligmentWeight = 2.0;\n        this.cohesionWeight = 4;\n        this.separationWeight = 0.3;\n\n        this.maxEntitySpeed = 5;\n        this.gravPull = 1;\n\n        this.aligmentRadius = 100;\n        this.cohesionRadius = 100;\n        this.separationRadius = 100;\n        this.obstacleRadius = 100;\n    }\n\n    /**\n     * Adds flock entity to boids container\n     * @param {Entity} entity \n     */\n    addFlockEntity(entity) {\n        this.grid.addEntity(entity);\n        this.flockEntities.push(entity);\n    }\n\n    /**\n     * Returns flock entities\n     * @returns {Array} flock entities\n     */\n    getFlockEntities() {\n        return this.flockEntities;\n    }\n\n    /**\n     * Adds obstacle entity to boids controller\n     * @param {Entity} entity \n     */\n    addObstacleEntity(entity) {\n        this.grid.addEntity(entity);\n        this.obstacleEntities.push(entity);\n    }\n\n    /**\n     * Returns obstacle entities\n     * @returns {Array} obstacle entities\n     */\n    getObstacleEntities() {\n        return this.obstacleEntities;\n    }\n\n    /**\n     * Returns world boundary\n     * @returns {Array} boundary vector\n     */\n    getBoundary() {\n        return [this.boundaryX, this.boundaryY, this.boundaryZ];\n    }\n\n    /**\n     * Sets max speed for flock entities.\n     * @param {Number} s \n     */\n    setMaxSpeed(s) {\n        this.maxEntitySpeed = s;\n    }\n\n    setGravPull(g) {\n        this.gravPull = g;\n    }\n\n    /**\n     * Sets aligment weight. This changes how much flock entities are effected by each others alignment\n     * @param {Number} w \n     */\n    setAligmentWeight(w) {\n        this.aligmentWeight = w;\n    }\n\n    /**\n     * Sets cohesion weight. This changes how much flock entities are inclined to stick together\n     * @param {Number} w \n     */\n    setCohesionWeight(w) {\n        this.cohesionWeight = w;\n    }\n\n    /**\n     * Sets separation weight. This changes how much flock entities are inclined to separate from each together\n     * @param {Number} w \n     */\n    setSeparationWeight(w) {\n        this.separationWeight = w;\n    }\n\n    /**\n     * Sets world boundary\n     * @param {Number} x \n     * @param {Number} y \n     * @param {Number} z \n     */\n    setBoundary(x, y, z) {\n        this.boundaryX = x;\n        this.boundaryY = y;\n        this.boundaryZ = z;\n    }\n\n    /**\n     * iterate calculates the new position for flock entities.\n     * start and end indices are used for parallelization of this calculation\n     * @param {Number} start start index for calculation\n     * @param {Number} end end index for calculation\n     */\n    iterate(start = 0, end = this.flockEntities.length) {\n        for (let i = start; i < end; i++) {\n            const entity = this.flockEntities[i];\n            const aligmentVel = this.computeAlignment(entity);\n            const cohVel = this.computeCohesion(entity);\n            const sepVel = this.computeSeparation(entity);\n            const obsVel = this.computeObstacles(entity);\n\n            // add components\n            const vx = this.aligmentWeight * aligmentVel[0] + this.cohesionWeight * cohVel[0] +\n                50 * this.separationWeight * sepVel[0] + 100 * obsVel[0];\n            const vy = this.aligmentWeight * aligmentVel[1] + this.cohesionWeight * cohVel[1] +\n                50 * this.separationWeight * sepVel[1] + 100 * obsVel[1];\n            const vz = this.aligmentWeight * aligmentVel[2] + this.cohesionWeight * cohVel[2] +\n                50 * this.separationWeight * sepVel[2] + 100 * obsVel[2];\n\n            entity.addVelocity(vx, vy, vz);\n            entity.move(this.maxEntitySpeed, this.boundaryX, this.boundaryY, this.boundaryZ, this.gravPull);\n        }\n    }\n\n    /**\n     * Computes alignment vector for the given entity\n     * @param {Entity} entity \n     * @returns {Array} alignment vector\n     */\n    computeAlignment(entity) {\n        let aligmentX = 0;\n        let aligmentY = 0;\n        let aligmentZ = 0;\n        let neighborCount = 0;\n\n        this.grid.getEntitiesInCube(entity.x, entity.y, entity.z, this.aligmentRadius, (currentEntity) => {\n            if (currentEntity != entity &&\n                currentEntity.getType() == _Entity_js__WEBPACK_IMPORTED_MODULE_0__.default.FLOCK_ENTITY &&\n                entity.getDistance(currentEntity) < this.aligmentRadius) {\n                neighborCount++;\n                aligmentX += currentEntity.vx;\n                aligmentY += currentEntity.vy;\n                aligmentZ += currentEntity.vz;\n            }\n        });\n\n        if (neighborCount > 0) {\n            aligmentX /= neighborCount;\n            aligmentY /= neighborCount;\n            aligmentZ /= neighborCount;\n            const aligmentMag = Math.sqrt((aligmentX * aligmentX) + (aligmentY * aligmentY) + (aligmentZ * aligmentZ));\n            if (aligmentMag > 0) {\n                aligmentX /= aligmentMag;\n                aligmentY /= aligmentMag;\n                aligmentZ /= aligmentMag;\n            }\n        }\n\n        return [aligmentX, aligmentY, aligmentZ];\n    }\n\n    /**\n     * Computes cohesion vector for the given entity\n     * @param {Entity} entity \n     * @returns {Array} cohesion vector\n     */\n    computeCohesion(entity) {\n        let cohX = 0;\n        let cohY = 0;\n        let cohZ = 0;\n        let neighborCount = 0;\n\n        this.grid.getEntitiesInCube(entity.x, entity.y, entity.z, this.cohesionRadius, (currentEntity) => {\n            if (currentEntity != entity &&\n                currentEntity.getType() == _Entity_js__WEBPACK_IMPORTED_MODULE_0__.default.FLOCK_ENTITY &&\n                entity.getDistance(currentEntity) < this.cohesionRadius) {\n                neighborCount++;\n                cohX += currentEntity.x;\n                cohY += currentEntity.y;\n                cohZ += currentEntity.z;\n            }\n        });\n\n        if (neighborCount > 0) {\n            cohX /= neighborCount;\n            cohY /= neighborCount;\n            cohZ /= neighborCount;\n\n            cohX = cohX - entity.x;\n            cohY = cohY - entity.y;\n            cohZ = cohZ - entity.z;\n\n            var cohMag = Math.sqrt((cohX * cohX) + (cohY * cohY) + (cohZ * cohZ));\n            if (cohMag > 0) {\n                cohX /= cohMag;\n                cohY /= cohMag;\n                cohZ /= cohMag;\n            }\n        }\n\n        return [cohX, cohY, cohZ];\n    }\n\n    /**\n     * Computes separation vector for the given entity\n     * @param {Entity} entity \n     * @returns {Array} separation vector\n     */\n    computeSeparation(entity) {\n        let sepX = 0;\n        let sepY = 0;\n        let sepZ = 0;\n        let neighborCount = 0;\n\n        this.grid.getEntitiesInCube(entity.x, entity.y, entity.z, this.separationRadius, (currentEntity) => {\n            let distance = entity.getDistance(currentEntity);\n            if (distance <= 0) {\n                distance = 0.01\n            }\n\n            if (currentEntity != entity &&\n                currentEntity.getType() == _Entity_js__WEBPACK_IMPORTED_MODULE_0__.default.FLOCK_ENTITY &&\n                distance < this.separationRadius) {\n                neighborCount++;\n                const sx = entity.x - currentEntity.x;\n                const sy = entity.y - currentEntity.y;\n                const sz = entity.z - currentEntity.z;\n                sepX += (sx / distance) / distance;\n                sepY += (sy / distance) / distance;\n                sepZ += (sz / distance) / distance;\n            }\n        });\n\n        return [sepX, sepY, sepZ];\n    }\n\n    /**\n     * Computes obstacle avoidance vector for the given entity\n     * @param {Entity} entity \n     * @returns {Array} obstacle avoidance vector\n     */\n    computeObstacles(entity) {\n        let avoidX = 0;\n        let avoidY = 0;\n        let avoidZ = 0;\n\n        this.grid.getEntitiesInCube(entity.x, entity.y, entity.z, this.obstacleRadius, (currentObstacle) => {\n            const distance = entity.getDistance(currentObstacle);\n            if (distance > 0 &&\n                currentObstacle.getType() == _Entity_js__WEBPACK_IMPORTED_MODULE_0__.default.OBSTACLE_ENTITY &&\n                distance < this.obstacleRadius) {\n                const ox = entity.x - currentObstacle.x;\n                const oy = entity.y - currentObstacle.y;\n                const oz = entity.z - currentObstacle.z;\n                avoidX += (ox / distance) / distance;\n                avoidY += (oy / distance) / distance;\n                avoidZ += (oz / distance) / distance;\n            }\n        });\n\n        // avoid boundary limits\n        const boundaryObstacleRadius = this.obstacleRadius / 4;\n        const distX = this.boundaryX - entity.x;\n        const distY = this.boundaryY - entity.y;\n        const distZ = this.boundaryZ - entity.z;\n        if (entity.x < boundaryObstacleRadius && Math.abs(entity.x) > 0) {\n            avoidX += 1 / entity.x;\n        } else if (distX < boundaryObstacleRadius && distX > 0) {\n            avoidX -= 1 / distX;\n        }\n        if (entity.y < boundaryObstacleRadius && Math.abs(entity.y) > 0) {\n            avoidY += 1 / entity.y;\n        } else if (distY < boundaryObstacleRadius && distY > 0) {\n            avoidY -= 1 / distY;\n        }\n        if (entity.z < boundaryObstacleRadius && Math.abs(entity.z) > 0) {\n            avoidZ += 1 / entity.z;\n        } else if (distZ < boundaryObstacleRadius && distZ > 0) {\n            avoidZ -= 1 / distZ;\n        }\n\n        return [avoidX, avoidY, avoidZ];\n    }\n\n    /**\n     * This methods serializes the whole boids controller with entities and\n     * returns as a simple object.\n     * @returns {Object} serialized BoidsController data\n     */\n    serialize() {\n        const flockEntities = [];\n        const obstacleEntities = [];\n        this.flockEntities.forEach(entity => {\n            flockEntities.push(entity.serialize());\n        });\n\n        this.obstacleEntities.forEach(entity => {\n            obstacleEntities.push(entity.serialize());\n        });\n\n        return {\n            subDivisionCount: this.subDivisionCount,\n            boundaryX: this.boundaryX,\n            boundaryY: this.boundaryY,\n            boundaryZ: this.boundaryZ,\n            flockEntities,\n            obstacleEntities,\n            aligmentWeight: this.aligmentWeight,\n            cohesionWeight: this.cohesionWeight,\n            separationWeight: this.separationWeight,\n            maxEntitySpeed: this.maxEntitySpeed,\n            aligmentRadius: this.aligmentRadius,\n            cohesionRadius: this.cohesionRadius,\n            separationRadius: this.separationRadius,\n            obstacleRadius: this.obstacleRadius\n        }\n    }\n\n    /**\n     * This methods serializes only the boids data for the given start and end indices.\n     * @param {Number} start \n     * @param {Number} end \n     * @returns {Object} serialized partial boids data\n     */\n    serializeBoidsData(start = 0, end = this.flockEntities.length) {\n        const flockEntities = [];\n        for (let i = start; i < end; i++) {\n            flockEntities.push(this.flockEntities[i].serialize());\n        }\n        return { start, flockEntities };\n    }\n\n    /**\n     * Applies the serialized boids data.\n     * @param {Object} data \n     */\n    applyBoidsData(data) {\n        const start = data.start;\n        const flockEntities = data.flockEntities;\n        for (let i = 0; i < flockEntities.length; i++) {\n            const entity = this.flockEntities[start + i];\n            const updatedData = flockEntities[i];\n            if (entity.id == updatedData.id) {\n                entity.updateData(updatedData);\n            } else {\n                console.log("ids do not match!");\n            }\n        }\n    }\n\n    /**\n     * This static method deserializes a boids controller data\n     * and creates a new BoidsController instance.\n     * @param {Object} data \n     * @returns {BoidsController} deserialized BoidsController instance\n     */\n    static deserialize(data) {\n\n\n        const controller = new BoidsController(data.boundaryX, data.boundaryY, data.boundaryZ, data.subDivisionCount);\n        controller.aligmentWeight = data.aligmentWeight;\n        controller.cohesionWeight = data.cohesionWeight;\n        controller.separationWeight = data.separationWeight;\n        controller.maxEntitySpeed = data.maxEntitySpeed;\n        controller.aligmentRadius = data.aligmentRadius;\n        controller.cohesionRadius = data.cohesionRadius;\n        controller.separationRadius = data.separationRadius;\n        controller.obstacleRadius = data.obstacleRadius;\n\n        data.flockEntities.forEach((entityData, i) => {\n            // console.log(data.avatars);\n            // let avatar = this.avatars[i % this.avatars.length];\n\n            const entity = _Entity_js__WEBPACK_IMPORTED_MODULE_0__.default.deserialize(entityData);\n\n\n            controller.addFlockEntity(entity);\n        });\n\n        data.obstacleEntities.forEach(entityData => {\n            const entity = _Entity_js__WEBPACK_IMPORTED_MODULE_0__.default.deserialize(entityData);\n\n\n            controller.addObstacleEntity(entity);\n        });\n\n        return controller;\n    }\n}\n\n//# sourceURL=webpack://sunstream/./src/boids/BoidsController.js?')},"./src/boids/BoidsWorker.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _BoidsController_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BoidsController.js */ \"./src/boids/BoidsController.js\");\n;\n\n/**\n * @module BoidsWorker \n * BoidsWorker is the wrapper for BoidsController to make it work inside a WebWorker context\n * The responsibility of this class is to create a new BoidsController instance with \n * the received data and run the requested iterations in this isolated context.\n */\nclass BoidsWorker {\n  constructor() {\n    this.boidsController = undefined;\n  }\n\n  /**\n   * Initializes the boids controller\n   * @param {Object} data \n   */\n  initializeBoidsController(data) {\n    this.boidsController = _BoidsController_js__WEBPACK_IMPORTED_MODULE_0__.default.deserialize(data);\n  }\n\n  /**\n   * Iterates the BoidsController with the provided parameters\n   * @param {Number} start \n   * @param {Number} end \n   * @param {Object} config \n   */\n  iterateBoidsController(start, end, config) {\n    this.boidsController.aligmentWeight = config.aligmentWeight;\n    this.boidsController.cohesionWeight = config.cohesionWeight;\n    this.boidsController.separationWeight = config.separationWeight;\n    this.boidsController.maxEntitySpeed = config.maxEntitySpeed;\n    this.boidsController.gravPull = config.gravPull;\n\n    this.boidsController.iterate(start, end);\n    const data = this.boidsController.serializeBoidsData(start, end);\n    postMessage({ action: 'iterateCompleted', data })\n  }\n\n  /**\n   * Updates the internal data of the BoidsController. When other BoidsWorkers have\n   * new data, it is send to other workers in order to keep all workers in sync.\n   * @param {Object} data \n   */\n  updateBoidsData(data) {\n    this.boidsController.applyBoidsData(data);\n  }\n\n  /**\n   * Message handler for the worker\n   */\n  onMessage(e) {\n    if (e.data.action == 'initialData') {\n      this.initializeBoidsController(e.data.data)\n    } else if (e.data.action == 'iterate') {\n      this.iterateBoidsController(e.data.start, e.data.end, e.data.config);\n    } else if (e.data.action = 'updateBoidsData') {\n      this.updateBoidsData(e.data.data)\n    }\n  }\n}\n\n// create instance\nconst worker = new BoidsWorker();\nonmessage = worker.onMessage.bind(worker);\n\n\n\n//# sourceURL=webpack://sunstream/./src/boids/BoidsWorker.js?")},"./src/boids/Entity.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => /* binding */ Entity\n/* harmony export */ });\nlet idCounter = 0;\n\n/**\n * @module Entity \n * Entity class defines an entitiy model which has a position and a velocity.\n * Also it has some utiliy methods.\n */\nclass Entity {\n    /**\n     * Constructor for the Entity class\n     * @param {Number} type entitiy type that defines it as flock or obstacle entitiy \n     * @param {Number} x x position\n     * @param {Number} y y position\n     * @param {Number} z z position\n     * @param {Number} vx x velocity\n     * @param {Number} vy y velocity\n     * @param {Number} vz z velocity\n     */\n    constructor(type, x = 0, y = 0, z = 0, vx = 0, vy = 0, vz = 0, mesh = null) {\n        this.id = ++idCounter;\n        this.type = type;\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.vx = vx;\n        this.vy = vy;\n        this.vz = vz;\n        this.grid = undefined;\n        this.mesh = undefined;\n        this.mesh = mesh;\n\n        this.stepCount = 0;\n\n        this.gPull =\n        {\n            offset: Math.random() * 1000,\n            delta: Math.random() * 4000 + 2000\n        }\n\n\n\n        this.FLOCK_ENTITY = 1;\n        this.OBSTACLE_ENTITY = 1;\n    }\n\n    /**\n     * Sets the grid instance\n     * @param {Grid} grid \n     */\n    setGrid(grid) {\n        this.grid = grid;\n    }\n\n    /**\n     * @returns {Number} type of the entity\n     */\n    getType() {\n        return this.type;\n    }\n\n    /**\n     * @returns {Number} the current scalar velocity of the entity.\n     */\n    getVelocity() {\n        return Math.sqrt((this.vx * this.vx) + (this.vy * this.vy) + (this.vz * this.vz));\n    }\n\n    /**\n     * Checks the velocity of the entitiy and limits it to the given parameter\n     * @param {Number} maxVelocity \n     */\n    checkVelocity(maxVelocity = 1) {\n        const velocity = this.getVelocity();\n\n        if (velocity > maxVelocity && velocity > 0) {\n            this.vx = maxVelocity * this.vx / velocity;\n            this.vy = maxVelocity * this.vy / velocity;\n            this.vz = maxVelocity * this.vz / velocity;\n        }\n    }\n\n    /**\n     * This method adds the given velocity to the current velocity.\n     * @param {Number} vx x velocity\n     * @param {Number} vy y velocity\n     * @param {Number} vz z velocity\n     */\n    addVelocity(vx, vy, vz) {\n        this.vx += vx;\n        this.vy += vy;\n        this.vz += vz;\n    }\n\n    /**\n     * This method moves the entity.\n     * @param {Number} maxVelocity \n     * @param {Number} bx \n     * @param {Number} by \n     * @param {Number} bz \n     */\n\n    calculateDistance(p1, p2) {\n        var a = p2.x - p1.x;\n        var b = p2.y - p1.y;\n        var c = p2.z - p1.z;\n\n        return Math.hypot(a, b, c);\n    }\n\n    getDirToCenter(p1, p2) {\n        let dir = { x: p1.x - p2.x, y: p1.y - p2.y, z: p1.z - p2.z };\n        let dist = Math.hypot(dir.x, dir.y, dir.z);\n        let normDir = { x: dir.x / dist, y: dir.y / dist, z: dir.z / dist };\n        return normDir;\n    }\n\n    getClosestPoint(p1, p2, radius, distance) {\n        let dir = { x: p1.x - p2.x, y: p1.y - p2.y, z: p1.z - p2.z };\n        let normDir = { x: dir.x / distance, y: dir.y / distance, z: dir.z / distance };\n        let closestPoint = {\n            x: p2.x + normDir.x * radius,\n            y: p2.y + normDir.y * radius,\n            z: p2.z + normDir.z * radius,\n\n        }\n        return closestPoint;\n    }\n    move(maxVelocity, bx, by, bz, gravity) {\n        this.checkVelocity(maxVelocity);\n        let nPos = {\n            x: this.x + this.vx,\n            y: this.y + this.vy,\n            z: this.z + this.vz\n        }\n\n        let radius = bx;\n        let root = { x: bx / 2, y: bx / 2, z: bx / 2 };\n\n        let distance = this.calculateDistance(nPos, root);\n        let weight = (distance) / (radius);\n        weight = Math.max(0, weight);\n        let iWeight = weight == 0 ? 1 : (1 - weight);\n\n        // gravity\n\n        let normDir = this.getDirToCenter(nPos, root);\n        let now = new Date().getTime() / this.gPull.delta;\n        let wave = (Math.sin(now + this.gPull.offset) / 3 + 4 / 3)  /* + (Math.abs(Math.sin(now / Math.PI)) * 2) */;\n        let gWeight = (Math.exp(weight)) * (1 / 2 + weight / 2) * -1 * wave * gravity;\n        if (!normDir.x || !gWeight) {\n            console.log("err");\n            console.log(normDir.x, gWeight);\n        }\n        nPos = {\n            x: nPos.x + normDir.x * gWeight,\n            y: nPos.y + normDir.y * gWeight,\n            z: nPos.z + normDir.z * gWeight,\n        }\n\n        this.grid.moveEntity(this, nPos.x, nPos.y, nPos.z);\n        this.stepCount++;\n    }\n\n    /**\n     * Calculate the distance between the entity and the given entity\n     * @param {Entity} otherEntity \n     * @returns {Number} the distance between two entities\n     */\n    getDistance(otherEntity) {\n        const dx = this.x - otherEntity.x;\n        const dy = this.y - otherEntity.y;\n        const dz = this.z - otherEntity.z;\n        return Math.sqrt((dx * dx) + (dy * dy) + (dz * dz));\n    }\n\n    /**\n     * Serialized the entitiy\n     * @returns {Object} serialized data\n     */\n    serialize() {\n        const { id, type, x, y, z, vx, vy, vz } = this;\n        return {\n            id, type, x, y, z, vx, vy, vz\n        }\n    }\n\n    /**\n     * Updates the internal data of the entity if the IDs match\n     * @param {Object} data \n     */\n    updateData(data) {\n        if (this.id == data.id) {\n            this.vx = data.vx;\n            this.vy = data.vy;\n            this.vz = data.vz;\n            this.grid.moveEntity(this, data.x, data.y, data.z);\n        }\n    }\n\n    /**\n     * This static method deserializes the given data and returns new Entity instance.\n     * @param {Object} data \n     * @returns {Entitiy} deserialized Entitiy instance\n     */\n    static deserialize(data) {\n        const e = new Entity(data.type, data.x, data.y, data.z, data.vx, data.vy, data.vz, data.avatar);\n        e.id = data.id;\n        return e;\n    }\n}\n\n//# sourceURL=webpack://sunstream/./src/boids/Entity.js?')},"./src/boids/Grid.js":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{eval('__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   "default": () => /* binding */ Grid\n/* harmony export */ });\n\n/**\n * @module Grid \n * Grid class creates cubic grid for spatial partitioning.\n * This helps lookups to be performed faster for nearby entities.\n * More information can be found here:\n * http://gameprogrammingpatterns.com/spatial-partition.html\n */\nclass Grid {\n    /**\n     * Constructor for the Grid class. Grids can be only be a cube. It takes cellSize as a parameter\n     * @param {Number} worldSize total world size in units. eg. 1000 \n     * @param {Number} cellSize cell size to divide the world into. eg. 20.\n     */\n    constructor(worldSize, cellSize) {\n        this.worldSize = worldSize;\n        this.cellSize = cellSize;\n        this.cellRowCount = (this.worldSize / this.cellSize)|0;\n        \n        this.cellCount = this.cellRowCount*this.cellRowCount*this.cellRowCount;\n        this.entityList = [];\n        for(let i=0; i<this.cellCount; i++) {\n            this.entityList[i] = [];\n        }\n    }\n\n    /**\n     * @returns {Number} world size\n     */\n    getWorldSize() {\n        return this.worldSize;\n    };\n\n    /**\n     * @returns {Number} grid count in a row\n     */\n    getGridRowCount() {\n        return this.cellRowCount;\n    };\n\n    /**\n     * Calculate the grid index for the given x,y,z position\n     * @param {*} x x position of the entity\n     * @param {*} y y position of the entity\n     * @param {*} z z position of the entity\n     * @returns {Number} index of the cell for the given point\n     */\n    getGridIndex(x, y, z) {\n        let cellX = (x / this.cellSize)|0;\n        let cellY = (y / this.cellSize)|0;\n        let cellZ = (z / this.cellSize)|0;\n\n        if(cellX < 0) {\n            cellX = 0;\n        } else if(cellX > this.cellRowCount-1) {\n            cellX = this.cellRowCount-1;\n        }\n\n        if(cellY < 0) {\n            cellY = 0;\n        } else if(cellY > this.cellRowCount-1) {\n            cellY = this.cellRowCount-1;\n        }\n\n        if(cellZ < 0) {\n            cellZ = 0;\n        } else if(cellZ > this.cellRowCount-1) {\n            cellZ = this.cellRowCount-1;\n        }\n\n        let index = cellX + cellY*this.cellRowCount + cellZ*this.cellRowCount*this.cellRowCount;\n        return index|0;\n    };\n\n    /**\n     * Adds the entity to the correspoding grid\n     * @param {Object} entity \n     */\n    addEntity(entity) {\n        const index = this.getGridIndex(entity.x, entity.y, entity.z)|0;\n        entity.setGrid(this);\n        this.entityList[index].push(entity);\n    };\n\n    /**\n     * Removes the entity from the correspoding grid\n     * @param {Object} entity \n     */\n    removeEntity(entity) {\n        const index = this.getGridIndex(entity.x, entity.y, entity.z)|0;\n        const gridEntities = this.entityList[index];\n        const entityIndex = gridEntities.indexOf(entity);\n        if(entityIndex == -1)\n        {\n            // serious error!\n            throw("removeEntity() can not find the entity to be removed!");\n            return;\n        }\n        else\n        {\n            gridEntities.splice(entityIndex, 1);\n            entity.setGrid(undefined);\n        }\n    };\n\n    /**\n     * Moves the entity. Checks the new grid index, if the given position\n     * requires entitiy move from cell to cell, it handles that transition.\n     * @param {Object} entity entitiy object\n     * @param {Number} newX new x position\n     * @param {Number} newY new y position\n     * @param {Number} newZ new z position\n     */\n    moveEntity(entity, newX, newY, newZ) {\n        const oldIndex = this.getGridIndex(entity.x, entity.y, entity.z)|0;\n        const newIndex = this.getGridIndex(newX, newY, newZ)|0;\n\n        if(oldIndex == newIndex) {\n            entity.x = newX;\n            entity.y = newY;\n            entity.z = newZ;\n            // no need to update\n            return;\n        }\n\n        // remove from the old grid list\n        const gridEntities = this.entityList[oldIndex];\n        const entityIndex = gridEntities.indexOf(entity);\n        if(entityIndex == -1)\n        {\n            // serious error!\n            throw("moveEntity() can not find the entity to be removed!");\n            return;\n        }\n        else\n        {\n            gridEntities.splice(entityIndex, 1);\n        }\n\n        // add to the new grid list\n        entity.x = newX;\n        entity.y = newY;\n        entity.z = newZ;\n        this.entityList[newIndex].push(entity);\n    };\n\n    /**\n     * Finds the corresponding grid for the given x,y,z position and\n     * returns the entities in that grid.\n     * @param {Number} x x position to find a cell\n     * @param {Number} y y position to find a cell\n     * @param {Number} z z position to find a cell\n     * @returns {Array} entity list for that grid\n     */\n    getEntitiesInGrid(x, y, z) {\n        const index = this.getGridIndex(x, y, z)|0;\n        return this.entityList[index];\n    };\n\n    /**\n     * Returns the entities in the grid with the given index\n     * @param {Number} index \n     * @returns {Array} entity list for that grid\n     */\n    getEntitiesInGridIndex(index) {\n        if(index < 0 || index >= this.cellCount)\n        {\n            throw("getEntitiesInGridIndex() out of bounds!");\n        }\n\n        return this.entityList[index|0];\n    };\n\n    /**\n     * This method finds the entities in the cube that is defined with an origin position and a size.\n     * The callback is executed for every entity that is found in the cube.\n     * @param {Number} originX x position for the cube\n     * @param {Number} originY y position for the cube\n     * @param {Number} originZ z position for the cube\n     * @param {Number} size size of the cube\n     * @param {Function} callback callback is executed for every entity that is found in the cube\n     */\n    getEntitiesInCube(originX, originY, originZ, size, callback) {\n        const start = this.getGridIndex(originX - size, originY - size, originZ - size); // top left\n        const topEnd = this.getGridIndex(originX + size, originY - size, originZ - size); // top right\n        const bottomStart = this.getGridIndex(originX - size, originY + size, originZ - size); // bottom left\n        const backStart = this.getGridIndex(originX + size, originY + size, originZ + size); // back left\n\n        const index = start;\n        const width = topEnd - start + 1;\n        const height = (((bottomStart - start)/this.cellRowCount) + 1)|0;\n        const depth = (((backStart - start)/(this.cellRowCount*this.cellRowCount)) + 1)|0;\n        for(let d=0; d<depth; d++) {\n            for(let h=0; h<height; h++) {\n                for(let w=0; w<width; w++) {\n                    const currentIndex = index + (d*this.cellRowCount*this.cellRowCount) + (h*this.cellRowCount) + w;\n                    if(currentIndex >= this.cellCount) {\n                        continue;\n                    }\n\n                    const currentItems = this.entityList[currentIndex];\n                    const curLen = currentItems.length;\n                    for(let i=0; i<curLen; i++) {\n                        const item = currentItems[i]\n                        if(item !== undefined &&\n                        item.x >= originX - size && item.x <= originX + size &&\n                        item.y >= originY - size && item.y <= originY + size && \n                        item.z >= originZ - size && item.z <= originZ + size)\n                        {\n                            callback(item);\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\n\n//# sourceURL=webpack://sunstream/./src/boids/Grid.js?')}},__webpack_module_cache__={};function __webpack_require__(n){if(__webpack_module_cache__[n])return __webpack_module_cache__[n].exports;var t=__webpack_module_cache__[n]={exports:{}};return __webpack_modules__[n](t,t.exports,__webpack_require__),t.exports}__webpack_require__.d=(n,t)=>{for(var e in t)__webpack_require__.o(t,e)&&!__webpack_require__.o(n,e)&&Object.defineProperty(n,e,{enumerable:!0,get:t[e]})},__webpack_require__.o=(n,t)=>Object.prototype.hasOwnProperty.call(n,t),__webpack_require__.r=n=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(n,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(n,"__esModule",{value:!0})},__webpack_require__("./src/boids/BoidsWorker.js")})();